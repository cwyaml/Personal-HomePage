<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript - 事件]]></title>
      <url>%2F2017%2F04%2F02%2Fevent%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Javascript 和 HTML 之间的交互是通过 事件 来实现的。最早在 IE 中出现，被作为分担服务器端运算负载的一种手段。到现在，几乎所有的浏览器都支持事件处理。在 DOM2 级中得到规范。 事件流事件流 描述的是从页面中接受事件的顺序。IE 和 Netscape 提出了完全相反的事件流概念。 事件冒泡： IE 中的事件流叫做 事件冒泡 ,即从最具体的元素逐级向外传播到较不具体的元素。（所有现代浏览器都支持事件冒泡）事件捕获： Netscape 提出了另一种事件流叫做 事件捕获 。他们的思想是最具体的元素应该最后接受到事件，所以事件捕获是 “从外向内” 传播的。DOM事件流： “DOM2级事件”规定了事件流包括三个阶段：首先发生事件捕获，然后是实际的目标接受到事件，最后一个阶段是事件冒泡。 汇总： IE8及更早的版本不支持 DOM2 级事件流。 事件处理程序事件就是用户或浏览器自身执行的某种动作。像click、load等都是事件的名字，而响应这个事件的函数就叫做 事件处理程序 。事件处理程序以 on 开头。Javascript 有三种事件模型：内联模型 、 脚本模型 和 DOM2级模型 。 内链模型： 被淘汰的方式，举个例子：1&lt;input type="button" value="Click me" onclick="alert('Clicked')" /&gt; 脚本模型： 这个是现在用的最多的一种方式：12345var btn = document.getElementById('button');btn.onclick = function()&#123; //指定事件 alert('Clicked');&#125;btn.onclick = null; //删除事件 DOM2级模型“DOM2级事件”定义了两个方法：（可用于所有 DOM 节点） addEventListener() &nbsp;&nbsp; 添加事件 removeEventListener() &nbsp;&nbsp; 移除事件 这两个方法都接受三个参数：要处理的事件名（click、mouseover）、事件处理程序（一个匿名函数） 和 一个布尔值（最后一个布尔值如果是 true 表示在捕获阶段执行事件，如果是 false 表示在冒泡阶段执行事件。） PS: 大多数情况下，都将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度兼容不同的浏览器。 1234var btn = document.getElementById('button');btn.addEventListener('click',function()&#123; alert('Clicked'); &#125;,false); DOM2方式的特点：1、可以为同一个元素添加多个事件处理程序，他们会按照顺序依次执行。2、移除事件貌似麻烦了很多。 123456789101112131415var btn = document.getElementById('button');btn.addEventListener('click',function()&#123; alert('Clicked'); &#125;,false);btn.removeEventListener('click',function()&#123; alert('Clicked'); //这样是不能移除事件的 &#125;,false); //因为这两个匿名函数已经不是同一个函数了//必须这样写var btn = document.getElementById('button');var handler = function()&#123; alert('Clicked');&#125;btn.addEventListener('click',handler,false);btn.removeEventListener('click',handler,false); //这样才行 IE中的事件处理程序IE 实现了与 DOM 中类似的两个方法： attachEvent() &nbsp;&nbsp; 添加事件 detachEvent() &nbsp;&nbsp; 移除事件 这两个方法接受两个参数：事件处理程序的名称（onclick、onmouseover） 和 事件处理函数（一个匿名函数）。（IE 默认使用冒泡方式） 需要注意的是它 DOM2 中两个方法的区别：区别一： 第一个参数是 onclick ，而不是 click 。区别二： 事件处理程序会在全局作用于下运行，里面的 this 指的是 window 。（在做跨浏览器是这一点要特别注意） 1234var btn = document.getElementById('button');btn.attachEvent('onclick',function()&#123; alert(this === window); //true &#125;); 优缺点：优点：同样可以添加多个事件处理程序。但是，这些事件是按添加的相反顺序执行。缺点：和上面一样，使用匿名函数是不能被移除。需要传入对相同函数的引用。 跨浏览器事件处理程序我们要创建一个方法，视情况分别使用 传统模型、DOM2级模型 或者 IE 事件处理程序。这个方法接受三个参数：要操作的元素、事件类型 和 事件处理函数。1234567891011121314151617181920//添加事件function addEvent(element,type,fn)&#123; if(element.addEventListener)&#123; element.addEventListener(type,fn,false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on'+type,fn); &#125;else&#123; element['on'+type] = fn; &#125;&#125;//移除事件function removeEvent(element,type,fn)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,fn,false); &#125;else if(element.detachEvent)&#123; element.detachEvent('on'+type,fn); &#125;else&#123; element['on'+type] = null; &#125;&#125; 事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如鼠标操作导致的事件对象中，包含鼠标位置的信息，键盘操作导致的事件对象中，包含与按键有关的信息。所有浏览器都支持 event 对象，不过支持的方式不同。 W3C中的事件对象无论指定事件处理程序时使用什么方法（DOM0级、DOM2级等），都会传入 event 对象。1234btn = document.getElementById('button');addEvent(btn,'click',function(event)&#123; alert(event.type); //click &#125;); event 对象的属性和方法： (这里之列举最常用的) 属性/方法 说明 target 事件的目标 type 被触发的事件类型 currentTarget 其事件处理程序当前正在处理事件的那个元素 cancelable 表明是否可以取消当前事件的默认行为 preventDefault() 取消时间的默认行为。如果 cancelable 是 true 就可以使用这个方法 bubbles 表明事件是否冒泡 stopPropagation() 取消时间的进一步捕获或冒泡。如果 bubbles 为 true 则可以使用这个方法 注意：1、在事件执行内部， this 始终等于 currentTarget 。而 target 只包含事件的实际目标。也就是说 this 和 currentTarget 返回的是你为事件指定的目标元素，而 target 是真正触发这个事件的目标。2、只有 cancelable 的值为 true 的事件，才可以使用 preventDefault() 来取消器默认行为。1234var link = document.getElementById('myLink');link.onclick = function(event)&#123; event.preventDefault(); //点击链接不会跳转&#125; 3、stopPropagation() 方法用于立即停止事件冒泡或捕获。12345678var btn = document.getElementById('button');btn.onclick = function(event)&#123; alert('Clicked'); event.stopPropagation(); //如果不阻止事件的传播，点击 btn 后下面的事件也会执行&#125;document.body.onclick = function()&#123; alert('Body Element');&#125; IE中的事件对象与访问 W3C 中的 event 对象不同，IE 中的 event 对象的访问 取决于指定事件处理程序的方法。脚本模式： event 作为 window 对象的一个属性存在1234btn.onclick = function()&#123; var event = window.event; alert(event.type); //click&#125; DOM2级： event 作为一个参数被传入事件处理程序。123btn.attachEvent('onlick',function(event)&#123; alert(event.type); //click &#125;); IE 中的 event 对象的属性和方法： 属性/方法 说明 cancelBubble 默认值为 false，将其设置为 true 时可以取消事件冒泡（相当于 DOM 中的 stopPropagation() 方法） returnValue 默认值为 true，将其设置为 false 是可以取消时间的默认行为（相当于 DOM 中的 preventDefault() 方法） srcElement 事件的目标（和 DOM 中的 target 一样） type 被触发事件的类型 注意：1、因为事件处理程序的 作用域 是由指定的方式决定的，所以要特别注意123456btn.onclick = function()&#123; alert(window.event.srcElement === this); //true&#125; //这里的this指的是btnDOMbtn.attachEvent('onclick',function(event)&#123; alert(event.srcElement === this); //false &#125;); //因为这里的this指的是window 2、只要将 returnValue 属性的值设置为 false 就可以阻止事件的默认行为1234var link = document.getElementById('myLink');link.onclick = function()&#123; window.event.returnValue = fasle; //链接不会跳转&#125; 3、cancelBubble 属性用来停止事件的冒泡（IE不支持事件捕获）这里就不举例了。 跨浏览器的事件对象这里有4个方法：123456789101112131415161718192021222324//获取对象function getEvent(event)&#123; return event ? event : window.event;&#125;//获取事件目标元素targetfunction getTarget(event)&#123; return event.target || event.srcElement;&#125;//阻止默认行为function preventDefault(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else if(event.returnValue)&#123; event.returnValue = false; &#125;&#125;//阻止冒泡function stopPropagation(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else if(event.cancelable)&#123; event.cancelable = true; &#125;&#125; 常用事件类型汇总常用的事件类型和具体用法你都可以在这里找到：HTML DOM 事件对象自己介绍一下 鼠标事件 和 键盘事件 鼠标事件当浏览器执行鼠标事件的时候回以函数的形式返回一个 event 对象event对象有一个 button 属相，按下鼠标的不同按键会返回不同的值（貌似很有用）12345678910document.onclick = function(event)&#123; event = event || window.event; alert(event.button); //chrome 左键弹出0 其它不支持；FF 左键0 中键1 右键2； //IE 左键0 中键1 右键不支持&#125;//尝试一次别的事件document.onmouseup = function(event)&#123; event = event || window.event; alert(event.button); //chrome 、IE 和 Firefox都符合W3C标准，做到了兼容&#125; 键盘事件键盘事件一共有三种：keydown &nbsp;&nbsp; 键盘按下是执行keyup &nbsp;&nbsp; 键盘松开是执行keypress &nbsp;&nbsp; 只支持字符键（能打印出字符的键，不包括enter、shift、Ctrl等）这里理解一个概念键码： 键盘上每个键都会对应一个数字，这个数字就称为键码。（字符的键码就是其对应的ASICC编码（字母的话按小写来），非字符也会有一个对应的值）。怎么获得这个键码呢？？用到event对象的另一个属性 keyCode1234document.onkeydown = function(event)&#123; event = event || window.event; alert(event.keyCode); //这时按下键盘上的每个键都会返回对应的键码&#125; 如果使用keypress方法来返回keyCode呢？12345document.onkeypress = function(event)&#123; event = event || window.event; alert(event.keyCode); //Chrome和IE 非字符键不返回，字符键返回对应ASCII编码，并且区分大小写 //forefox 非字符键不返回，字符键全部返回 0&#125; 注意：键码在不同浏览器上可能会有所不同（比如 ; 分号，，可以自己试一下）。那么怎么做到兼容呢？？再来认识一个概念：字符编码： 这个是唯一的1234 document.onkeypress = function(event)&#123; event = event || window.event; alert(event.charCode); //返回对应的字符编码，（;分号可以兼容了）&#125; 如果只用到字符的事件就用 keypress 的 charCode方法 事件委托由于事件处理程序可以为现代 WEB 应用程序提供交互能力，因此许多开发人员会不分青红皂白地想页面中添加大量的处理程序。这样做会导致什么问题呢？首先，每个函数都是对象，都会占用内存；其次，必须事件指定好所有事件处理程序而导致 DOM 访问次数过多，延迟整个页面的交互就绪时间。对“事件处理程序过多”问题的解决方案就是 事件委托 。事件委托利用 事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。举个例子： 下面是三个不同的按钮。12345&lt;div id="box"&gt; &lt;button id="btn1"&gt;这是按钮A&lt;/button&gt; &lt;button id="btn2"&gt;这是按钮B&lt;/button&gt; &lt;button id="btn3"&gt;这是按钮C&lt;/button&gt;&lt;/div&gt; 我们要为他们指定 click 事件，传统意义上我们会分别为他们指定事件，就像下面这样做：123456789101112var btn1 = document.getElementById('btn1');var btn2 = document.getElementById('btn2');var btn3 = document.getElementById('btn3');btn1.click = function()&#123; alert('这是按钮A！');&#125;btn2.click = function()&#123; alert('这是按钮B！');&#125;btn3.click = function()&#123; alert('这是按钮C！');&#125; 在来看看用 事件委托 应该怎么做：123456789101112131415addEvent(document,'click',function(event)&#123; var event = getEvent(event); var target = getTarget(event); switch(target.id)&#123; case 'btn1': alert('这是按钮A！'); break; case 'btn2': alert('这是按钮B！'); break; case 'btn3': alert('这是按钮C！'); break; &#125;&#125;); 对比就会发现这种方式的优势，首先，我们只指定了一个事件就完成了为三个按钮添加事件的功能，较少了程序运行所需的内存；另外，只有一次 DOM 操作，这使得交互会很快就绪。是不是很完美。 适合采用 事件委托 的事件包括 click、mousedown、mouseup、keydown、keyup 和 keypress。(必须支持事件冒泡)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub 文本编辑器 Atom]]></title>
      <url>%2F2017%2F04%2F02%2Fatom%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在代码编辑器、文本编辑器领域，有着不少的「神器」级的产品，如历史悠久的 VIM、Emacs 以及如今当红的 SublimeText。另外还有 VS Code、EditPlus、NotePad++、UltraEdit 等一大堆流行的利器，可谓百家争鸣。 简介作为目前全球范围内影响力最大的代码仓库/开源社区，GitHub 的程序员们并不满足于此。他们使用目前最先进流行的技术重新打造了一款称为“属于21世纪”的代码编辑器——Atom， 它开源免费跨平台，并且整合 GIT 并提供类似 SublimeText 的包管理功能，支持插件扩展，可配置性非常高…… 优点 开源，完全 免费； 它提供了与 SublimeText 上类似的 Package Control (包管理)功能，人们可以非常方便地安装和管理各种插件，并将 Atom 打造成真正适合自己的开发工具； Atom 编辑器可以和 GIT 完美结合，所有对代码、文本的修改都能体现在编辑器的界面上。比如在文件内新写的代码会在左边标记为绿色，删除的标记为红色，修改的标记为黄色。在左边的目录导航也能方便的看到文件改动：有改动的文件其文件名和所在文件夹名都会被标记为高亮显示。编辑器底部会显示当前所在分支和对文件的修改行数统计，对于 GIT 用户来说非常方便。 对前端友好。基于 WEB 技术（Chromium+Node.js）开发的，这足以让无数 WEB 工程师为之兴奋！用户可以用 Javascript 来编写编辑器插件，用 CSS 把主题界面改成任何你喜欢的样式等，这使得编写插件、主题、二次开发的门槛的降低了许多。这也能解释从 Atom 发布到现在不长的时间里，Atom 的 Package 和主题数量都快速增长上来了。 缺点 启动速度慢，打开大文件慢，貌似就这一个缺点！！ 常用插件Package推荐 atom-simplified-chinese-menu 汉化（如果你需要的话） Emmet 前端神器 javascript-snippets js中的 emmet minimap 小地图（跟 sublime 上的一样） docblockr 养成良好的注释习惯 atom-beautiful 代码格式化。支持HTML, CSS, JavaScript, PHP, Python, Ruby, Java, C, C++, C#, Objective-C….. pigments 显示颜色（rgb等都会显示） tree-view-background 左侧文件列表背景图片（个人感觉很简介、方便） Sublime-Style-Column-Selection 列编辑（也是sublime中的功能） markdown-scroll-sync 编辑markdown时预览页面随光标移动 highlight-selected 选中时相同文本高亮 vimMode 如果你会使用 vim 的话（如果你不会的话最好别装，因为会有好多快捷键冲突） autocomplete-plus 当输入时提供可能的候选项 autocomplete-paths 路径自动补全 activate-power-mode 动感打字特效（这个很火但是我不喜欢） Thems推荐 atom-material-ui 非常漂亮的一个主题 monokai 代码高亮 常见问题汇总关于安装插件不知道是什么原因，在编辑器里面搜索插件，一直安装不成功，翻墙也不行。所以只能本地安装。1、先把插件代码库 clone 到 atom 的 插件源码目录 （如果你不知道这个文件夹在哪的话，在设置中可以直接打开）。2、在 插件文件夹中 执行 npm install (注意不要用 apm install) 可能会报错，说你的 npm 版本低什么的，不要管，大概几分钟时间，一直等下去就会安装成功。 怎么修改UI1、打开 文件 &gt; 用户样式设置 就会显示编辑器主题 style 文件，我们可以用 css 语言来自定义样式。2、Ctrl+shift+I 快捷键打开开发者工具（跟 chrome 上的一样），你就会发现定义主题是如此的简单。 ###代码括号配对高亮atom 默认的括号匹配太不明显了，跟没有差不多。修改方法：在用户样式设置文件中添加12345//匹配括号atom-text-editor.editor .bracket-matcher .region &#123; border-top:yellow; border-bottom:yellow;&#125; 隐藏缩进指示线（中间的白线）解决方案：编辑 &gt; 用户样式设置，添加以下代码：123atom-text-editor::shadow .wrap-guide &#123; visibility: hidden;&#125; 设置菜单的字体太小解决方案：编辑 &gt; 用户样式设置，添加以下代码：123.settings-view &#123; font-size: 16px;&#125; 文件标题的字体太小解决方案：编辑 &gt; 用户样式设置，添加以下代码：123.tab-bar .tab .title &#123; font-size: 13px;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript - Ajax学习笔记]]></title>
      <url>%2F2017%2F03%2F30%2FAjax%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2005年 Jesse James Garrett 发表了一篇文章，介绍了 Ajax 这门技术。这种技术能够向服务器请求额外的数据而无需刷新页面，带来了很好的用户体验，一时间席卷全球。 XMLHttpRequestAjax 技术的核心是 XMLHttpRequest 对象（简称XHR）。这是微软首先引入的一个特性，其他浏览器后来也都有相同的实现。XHR 为向服务器请求和解析服务器响应提供了流畅的接口。用异步的方式从服务器获取更多信息。这意味着，只要用户触发了某一事件，再不刷新网页的情况下，更新服务器最新数据。 虽然 Ajax 中的 X 代表 XML ，但 Ajax 通信和数据格式无关，也就是说这种技术不一定使用 XML。 XHR使用方法XHR 对象的使用方法总体上分为三步：第一步： 创建 XMLHttpRequest 对象。W3C 支持原生的 XMLHttpRequest 对象，IE6使用的是 MSXML 库中的 ActiveXObject 对象，所以要做兼容！123456789101112131415161718192021function createXHR()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject != 'undefined')&#123; var version = [ 'MSXML2.XMLhttp.6.0', 'MSXML2.XMLhttp.3.0', 'MSXML2.XMLhttp' ]; for(var i = 0;i &lt; version.length;i++)&#123; try&#123; return new ActiveXObject(); &#125;catch(e)&#123; //跳过 &#125; &#125; &#125;else&#123; throw new Error('不支持Ajax！！'); &#125;&#125;var xhr = createXHR(); //创建对象 第二步： 准备发送请求用 open() 方法，接受三个参数：发送方式（get/post）、请求的 url、同步或者异步（同步为false、异步为true）1xhr.open('get','demo.php','false'); php 文件内容为：123&lt;?php echo Date('Y-m-d H:i:s'); //当前时间?&gt; 第三步： 发送请求 send() 方法 ，接受一个参数作为请求主体发送的数据（非 post 方式一般填 null 即可）1xhr.send(null); 同步方式当请求发送到服务器端，收到响应后，相应的数据会自动填充 XHR 对象的属性。一共有四个属性： 属性 返回值 responseText 作为响应主体被返回 responseXML 如果响应主体内容类型是 text/xml 或 application/xml，返回包含响应数据的 XMLDOM 文档 status 响应的 HTTP 状态 statusText HTTP 状态的说明 接受响应之后，第一步检查 status 属性，以确定响应已经成功返回。一般把 HTTP 状态代码为 200 作为成功的标志。（304 代表本地缓存中存在请求的页面缓存，也是响应成功的标志）12345678910document.onclick = function()&#123; var xhr = createXHR(); xhr.open('get','demo.php',false); xhr.send(null); if(xhr.status == 200)&#123; alert(xhr.responseText); &#125;else&#123; alert('请求失败'); &#125;&#125; 注意: 同步方式 send() 后才能收到返回数据 异步方式：使用异步调用才是我们真正常用的手段。使用异步调用的时候 ，需要触发 readystatechange 事件，然后检测 readyState 属性值。值为 4 时表示 接受到全部响应数据，并且可以使用。1234567891011121314document.onclick = function()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; //完全响应 if(xhr.status == 200)&#123; alert(xhr.responseText); &#125;else&#123; alert('请求失败！'); &#125; &#125; &#125; xhr.open('get','demo.php',true); xhr.send(null);&#125; PS: readystatechange 事件要放在发送请求之前！！！ GET方式GET方式主要用于向服务器请求获取数据，反应在 URL 中：123456789101112131415161718192021222324document.onclick = function()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200 || xhr.status == 304)&#123; alert(xhr.responseText); &#125;else&#123; alert('Ajax错误！'); &#125; &#125; &#125;; var url = 'demo.php'; url = addURLParam(url,'name','cwyaml'); url = addURLParam(url,'age',100); xhr.open('get',url,true); xhr.send(null);&#125;//编码函数function addURLParam(url,name,value)&#123; url += url.indexOf('?') == -1 ? '?' : '&amp;'; url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url;&#125; POST方式在 send() 执行之前需要修改头部信息1234567891011121314151617181920document.onclick = function()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200 || xhr.status == 304)&#123; alert(xhr.responseText); &#125;else&#123; alert('Ajax错误！'); &#125; &#125; &#125;; var url = strParam('name','cwyaml'); url += strParam('age',23); xhr.open('get','demo.php',true); xhr.send(url);&#125;//字符编码function strParam(name,value)&#123; return encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&amp;';&#125; 浏览器兼容这里的实现方式和 JQuery 实现 Ajax 的方式相同123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//创建对象function createXHR()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; //W3C return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject != 'undefined')&#123; //IE var version = [ 'MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp' ]; for(var i = 0;i &lt; version.length;i++)&#123; try&#123; return new ActiveXObject(version[i]); &#125;catch(e)&#123; //跳过！ &#125; &#125; &#125;else&#123; throw new Error('不支持Ajax!'); &#125;&#125;//Ajax请求function ajax(obj)&#123; var xhr = createXHR(); obj.date = strParam(obj.date); //字符编码是为了解决IE缓存问题 //判断异步 if(obj.async === true)&#123; xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; callback(); &#125; &#125; &#125; //判断get if(obj.method === 'get')&#123; obj.url = obj.url + '?rand=' + Math.random() + '&amp;' + obj.date; xhr.open(obj.method,obj.url,obj.async); xhr.send(null); &#125; //判断post if(obj.method === 'post')&#123; xhr.open(obj.method,obj.url,obj.async); xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.send(obj.date); &#125; //判断同步 同步要放在 send 后面！！！一定要注意 if(obj.async === false)&#123; callback(); &#125; function callback()&#123; if(xhr.status == 200)&#123; obj.success(xhr.responseText); &#125;else&#123; alert('Ajax错误！'); &#125; &#125;&#125;//字符编码function strParam(date)&#123; var arr = []; for(var i in date)&#123; arr.push(encodeURIComponent(i) + '=' + encodeURIComponent(date[i])); &#125; return arr.join('&amp;');&#125;//调用方法document.onclick = function()&#123; ajax(&#123; method : 'get', url : 'demo.php', date:&#123; 'name' : 'cwyaml', 'age' : 123 &#125;, success : function(text)&#123; alert(text); &#125;, async : true &#125;);&#125; 总结在写浏览器兼容的时候出现了一个问题：同步请求时 xhr.status 始终返回 0 。这令我百思不得其解，检查代码好几遍没发现错误，上百度找解决办法也没有结果，折腾了一上午时间才发现原来 把同步请求写在了 send() 前面 。我也是醉了，同步是单线程的，不发送请求怎么能得到返回数据。不过这也是学习中的一点乐趣，解决问题后的心情还是很爽的。以后一定要细心再细心，不要再这些小问题上浪费太多时间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建PHP环境]]></title>
      <url>%2F2017%2F03%2F30%2Fphp%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习 JS Ajax 之前，先来搭建一个本地服务器环境。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用 WampServer，它集成了PHP + Apache + MySQL，并且有 phpmyAdmin 可视化数据库，这个对我这个新手前端来说还是很有必要的。 功能介绍PHP： PHP 是一种后台操作语言，可以制作 web 页面，创建 ajax 请求，访问数据库的请求，操作数据库表格等。MySQL： MySQL 是数据库的服务。如果没有开启 Mysql 服务，php 中的脚本不能链接到数据库，请求服务时会提示没有 mysql 对象。Apache： Apache 服务，它可以解析 html 文件，解析 php 文件，提供 html 发出的 http 请求，并响应这个请求，返回给 html 一个 php 或者其他后台脚本的请求，如果你不开启 Apache 的服务，请求不能进行，无法使用 php 访问后台数据。这是一个中间的过程，目前的理解是这样的。 总结:前端访问后台，总共需要三个过程：首先，html 通过 Apache 服务请求 php 文件，或者其他 url 链接，如果是访问本地 php 文件，则要求两个文件在同一个服务下；第二步，php 文件被 Apache 服务器解析，执行 php 文件，访问后台数据库；第三步，执行 php 文件里的指令，访问数据库中的表，返回数据作为 html 文件中创建的请求的响应。 安装软件到 WampServer官网 下载最新版本。安装很简单，一路 next 即可。最后让你选择默认浏览器和编辑器，默认就好。安装完成后用浏览器访问 localhost 就能看到： Tools 栏目:phpinfo() 查看PHP的详细配置信息；phpmyadmin 可以使用其管理界面对数据库进行管理！Your Aliases栏目：adminer 和 phpmyadmin 是对数据库进行讲解的，phpsysinfo 是用来对PHP程序进行分析的。 加载php文件以后你自己做的 PHP 文件（html文件也行了）就放在 www 下就可以了。 上面 localhost 打开的其实就是这个文件夹下面的 index.php 文件。里面的文件都可以删除。 举个例子：打开 www 目录：新建一个文件夹 website 再在里面新建一个 index.php 文件，在里面输入：123&lt;?phpecho "这是一个测试文件！";?&gt; 保存（要用 UTF-8 格式）在浏览器中输入 localhost/website 就会显示这个 php 文件了。 切换语言： 打开软件后，默认最小化在系统的任务栏里。右键点击 &gt; language &gt; chinese 切换到中文。 还需要一些常用的配置。 MySQL以及phpmyAdmin配置MySQL是数据库服务，顾名思义就是用来管理数据库的。（数据库就是你硬盘里的一个文件夹） 设置密码： 左键点击软件选中 phpmyAdmin 就会进入数据库用户登录界面。默认用户名为：root &nbsp;&nbsp; 默认密码为空。 进入后选择账户，我们会看到已经有两个默认账户了。我们来给 root 用户修改密码。点 root 用户后面用户权限，然后修改密码后执行。 这一步只是修改了 phpmyAdmin 账户密码，还需要修改 MySQL 密码。 依次进入 wamp64\apps\phpmyadmin4.6.4 找到 config.inc.php 文件，修改 $cfg[&#39;Servers&#39;][$i][&#39;password&#39;] 的值（就是你刚才改的密码）。然后保存，重启 phpmyAdmin 输入用户名和密码就可以了。 创建用户： 点击新建用户，填入用户名和密码，勾选创建与用户同名的数据库并授予所有权限，勾选全局权限，然后执行。 以后就使用我们新建的这个数据库。 修改后是这个样子： Apache配置更改根目录：www目录 默认为 X:\wamp\www，也就是 wampserver 安装目录下的 www文件夹。实际使用中，默认设置往往不是我们想要的，可能改成其他文件夹更适合，比如 D:\site 或者 E:\www 等等。那该如何更改呢？ 下面以改为 D:\site 为例： 打开 wamp\scripts\config.inc.php第47行 $wwwDir = $c_installDir.’/www’;改为：$wwwDir = &#39;D:/site&#39;; $c_installDir 是个变量，指 WAMPserver 安装根目录。 打开 wamp64\bin\apache\apache2.4.23\conf\httpd.conf修改 DocumentRoot 后面双引号中的值比如将 DocumentRoot ‘D:/wamp/www/‘’改成 DocumentRoot &#39;D:/site/&#39;同时将 &lt;Directory ‘D:/wamp/www/‘&gt;改成 &lt;Directory &#39;D:/site/&#39;&gt;; 修改默认端口找到 Apache 安装目录下的 httpd.conf 文件（在 wamp 上的 Apache 项下面）打开它，找到 Listen 80（IPV4）、Listen [::0]:80(IPV6) 和 ServerName localhost:80 紧接着 Listen 的数字就是端口号，默认状态下为 80 。修改为 8080 保存即可。 上面只是修改了 Apache 服务的端口，还要修改： 找到 X:\wamp\wampmanager.tpl 文件，用文本编辑器打开，Ctrl+F 搜索 http://localhost 关键字，改成下面：12Type: item; Caption: "$&#123;w_localhost&#125;"; Action: run; FileName: "$&#123;c_navigator&#125;"; Parameters: "$&#123;c_edge&#125;http://localhost:8080$&#123;UrlPort&#125;/"; Glyph: 27Type: item; Caption: "$&#123;w_phpmyadmin&#125;"; Action: run; FileName: "$&#123;c_navigator&#125;"; Parameters: "$&#123;c_edge&#125;http://localhost:8080$&#123;UrlPort&#125;/phpmyadmin/"; Glyph: 28 PS： 网上还有一些配置，比如说外网访问什么的，个人感觉不需要，自己也没去实验就不写了！！什么时候用到了在折腾。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript - JSON学习笔记]]></title>
      <url>%2F2017%2F03%2F29%2Fjson%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前几天学习了 XML ，趁热打铁也把 JSON 做一下总结。首先 JSON 也是一种结构化数据，它的产生解决了 XML 过于繁琐的问题。它是 JS 的一个严格子集，利用 js 中的一些模式来表述数据化结构。不仅仅是 JS ，java、.NET 等其他语言也可以对 JSON 进行解析和序列化。 JSON语法JSON 的语法可以表示三种类型的值：简单值（字符串、数值、布尔值和null）、对象和数组。（JSON 中没有 undefined）JSON 简单值：1100,cwyaml,true,null //这些都是JSON简单值 JSON 对象：1'&#123;"name":"cwyaml","age":23&#125;' JSON 数组：1'[100,"cwyaml",true]' 相比普通的对象和数组，JSON 对象和数组少了结尾的分号和变量赋值，但是要用单引号包裹，用字符串形式表示。最常用的 JSON 形式：1234567891011121314[&#123; "name" : "a", "num" : 1 &#125;,&#123; "name" : "b", "num" : 2 &#125;,&#123; "name" : "c", "num" : 3&#125;] ECMAScript5 对解析 JSON 的行为进行了规范，定义了全局对象JSON。但是支持这个对象的浏览器有IE8+ FireFox3.5+ Safari4+ Chrome10.5+ 。（版本较高），不支持的浏览器可以通过一个开源库 json.js 来模拟执行。 JSON 对象提供了两个方法： stringify()方法stringify() &nbsp;&nbsp; 将源生的 js 值转换为 JSON 对象这个方法可以传三个参数，分别是需要转换的对象，过滤参数（数组的形式），转换的格式。最简单的用法：1234567891011var box = [ &#123; name : 'a', num : 1 &#125;,&#123; name : 'b', num : 2 &#125;];var str = JSON.stringify(box);alert(str); //[&#123;"name":"a","num":1&#125;,&#123;"name":"b","num":2&#125;] 三个参数：123456789101112var str = JSON.stringify(box,['name'],4);console.log(str); //打印出来的字符串是有格式的： [ &#123; "name": "a" &#125;, &#123; "name": "b" &#125;] 第二个参数也可以是一个函数：12345678var str = JSON.stringify(box,function(key,value)&#123; if(key == 'name')&#123; return 'Mr.' + value; &#125;else&#123; return value; &#125;&#125;);console.log(str); //[&#123;"name":"Mr.a","num":1&#125;,&#123;"name":"Mr.b","num":2&#125;] parse()方法parse() &nbsp;&nbsp; 将JSON 字符串转换为js原生值12345678910111213var box = '[&#123;"name":"a","num":1&#125;,&#123;"name":"b","num":2&#125;]';var json = JSON.parse(box);alert(json[0].name); //a//也可以传递两个参数var json = JSON.parse(box,function(key,value)&#123; if(key == 'name')&#123; return 'Mr'+ value; &#125;else&#123; return value; &#125; &#125;);alert(json[0].name); //Mr.a]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript - XPath学习笔记]]></title>
      <url>%2F2017%2F03%2F12%2FxPath%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XPath 是一种节点查找手段。它比使用 标准DOM 去查找 XML 节点更加方便、更加简单。但是 XPath 是 DOM3 中才支持的标准，并且 IE 有自己的实现方式。（IE总是自己造马车） IE中的XPathIE 提供了两种方法： selectSingleNode() 获取单一节点 123456var xmlStr = '&lt;root&gt;&lt;user id="1"&gt;Tom&lt;/user&gt;&lt;user id="2"&gt;Lucy&lt;/user&gt;&lt;/root&gt;';var xmlDom = parseXML(xmlStr); //创建xmlDom对象var node = xmlDom.selectSingleNode('root/user'); //种方式称为节点树查找，必须从最外层开始，由外向内//只会获得第一个 useralert(node.tagName); //user selectNodes() 获取节点集合 12345var nodes = xmlDom.selectNodes('root/user'); //返回的是一个数组alert(nodes.length); //2//一般这样用var nodes = xmlDom.selectNodes('root[1]/user'); //获取第二个root下的所有user W3C中的XPath在 DOM3 中 XPath 规范中，最重要的两个类型是 XPathEvaluator 和 XPathResult 。其中 XPathEvaluator 用于在特定上下文对 XPath 表达式求值。 XPathEvaluator 方法一共需要传递五个参数：1.XPath路径 2.上下文节点 3.命名空间求解器（null） 4.返回结果类型 5.保存结果的 XPath 对象（null）获取成功就返回对应的类型值，获取失败返回 null。 返回的结果类型一共有十种，常用的就两种： 常量 值 XPathResult_FIRST_ORDERED_NODE_TYPE 返回单一节点 XPathResult_ORDERED_NODE_ITERATOR_TYPE 返回节点集合 获取单一节点1234var result = xmlDom.evaluate('root/user',xmlDom,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null);if(result !== null)&#123; alert(result.singleNodeValue.textContent); //Tom &#125; 获取节点集合获取的时候只需要把返回值的类型修改为 获取节点集合 即可。得到的节点集合需要用 iterateNext() 方法使用迭代方法存入一个数组。这样就可以对数据进行操作了。12345678910var result = xmlDom.evaluate('root/user',xmlDom,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE,null);if(result !== null)&#123; var nodes = []; var node = result.iterateNext(); while(node !== null)&#123; nodes.push(node); node = result.iterateNext(); &#125;console.log(nodes[1].innerHTML); //Lucy&#125; XPath 常用语法XML加载之后就可以使用标准DOM来进行各种操作，比如上面的返回 tagName 。当然 XPath 也提供了一套方法：（这里只列举最常用的） 相同标签问题12var node = xmlDom.selectSingleNode('root/user[1]'); alert(serializeXML(node)); //&lt;user id="2"&gt;Lucy&lt;/user&gt; 第二个user IE中下标从 0 开始！！ W3C中下标从 1 开始！！ 获取元素内文本 12var node = xmlDom.selectSingleNode('root/user/text()');alert(serializeXML(node)); //Tom 跨结构查找(不关心结构层次) 123var node = xmlDom.selectSingleNode('//user'); //查找整个文档中第一个uservar node = xmlDom.selectSingleNode('b//user'); //也可以限制在一个标签内查找alert(serializeXML(node)); 通过属性查找 12var node = xmlDom.selectSingleNode('root/user[@id=2]');alert(serializeXML(node)); //&lt;user id="2"&gt;Tom&lt;/user&gt; 跨浏览器兼容鉴于IE中的相对功能较少，首先考虑 W3C。 获取单一节点1234567891011121314151617181920212223//获取单一节点 function selectSingleNode(xmlDom,xpath)&#123; var node = null; if(typeof xmlDom.evaluate != 'undefined')&#123; //W3C //让下标从 0 开始 var patten = /\[(\d+)\]/; var flag = xpath.match(patten); var num = 0; if(flag != null)&#123; num = parseInt(RegExp.$1) + 1; xpath = xpath.replace(patten,'[' + num + ']'); &#125; var result = xmlDom.evaluate(xpath,xmlDom,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null); if(result !== null)&#123; node = result.singleNodeValue; &#125; &#125;else if(typeof xmlDom.selectSingleNode != 'undefined')&#123; //IE node = xmlDom.selectSingleNode(xpath); &#125; return node;&#125; 获取节点集合1234567891011121314151617181920212223242526//获取节点集合function selectNodes(xmlDom,xpath)&#123; var nodes = []; if(typeof xmlDom.evaluate != 'undefined')&#123; //W3C //让下标从 0 开始 var patten = /\[(\d+)\]/; var flag = xpath.match(patten); var num = 0; if(flag != null)&#123; num = parseInt(RegExp.$1) + 1; xpath = xpath.replace(patten,'[' + num + ']'); &#125; var result = xmlDom.evaluate(xpath,xmlDom,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE,null); if(result !== null)&#123; var node = null; while((node = result.iterateNext())!= null)&#123; nodes.push(node); &#125; &#125; &#125;else if(typeof xmlDom.selectNodes != 'undefined')&#123; //IE nodes = xmlDom.selectNodes(xpath); &#125; return nodes;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HEXO+GitHub,搭建博客 - 域名绑定]]></title>
      <url>%2F2017%2F03%2F09%2Fwwwyuming%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面也讲过了，我们把博客同时托管到 Github 和 Coding。我们就有两个域名可以访问站点，但是又出现几个问题：使用的不是自己的域名；两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并；github pages国内访问速度慢（300ms左右，毕竟国外的服务器）。 这就有点坑爹了，强迫症怎么能忍。下面给出解决方法。。 解决方案：我们知道 github 和 coding 的 pages 服务都提供 自定义域名 功能。我们可以利用这一点，绑定自己的域名。域名解析的时候实现国内访问 coding pages ，国外访问 github pages ,从而加快访问速度。 具体怎么实现，往下看： 购买域名首先我们要购买一个域名，推荐到 万网 购买。（毕竟很方便）具体步骤可以参考这篇文章：万网域名注册教程。 购买域名一定要实名认证，否则会停止解析 域名解析这一步是最重要的，我们要把域名指向 github 和 coding 的服务器空间。 登录阿里云，进入 控制台 。依次点击 域名与网站 &gt; 云解析DNS 就会出现你购买的域名信息 点击 解析，然后按照下图依次添加解析：（这张图片可以放大） 从上图可以看出，我们的解析实现了分流。国内线路访问Coding pages，国际线路访问Github Pages。 托管平台设置Coding平台进入对应项目的 pages 设置页面（项目 &gt; 代码 &gt; pages服务） 成功后会显示： Github平台进入对应项目的 pages 设置页面（setting &gt; github pages &gt; Custom domain) 成功后会显示： 到此我们的博客就可以正常运行了！！ 总结一切搞定后，在回头看一下我们的问题：@ 两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并； 从两个地址访问都会跳转到我们绑定的域名。统计信息自然也是绑定后域名的信息。 @ github pages国内访问速度慢（300ms左右） 我们测试一下 Ping：(表现不错) @ 托管平台给出的二级域名太丑。 不存在的…..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript-XML学习笔记]]></title>
      <url>%2F2017%2F03%2F08%2Fxml%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML 是指可扩展标记语言。 被设计用来 传输 和 存储数据。（可以理解为微型的数据库）很重要也非常好学。曾几何时，XML一度成为存储和传输结构化数据的标准。DOM 出现以后，所有浏览器都内置了对 XML 的原生支持（XML DOM），同时也提供了一系列相关的技术支持。 简介先看一下XML长什么样子吧：123456&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!--声明--&gt;&lt;book&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;author&gt;cwyaml&lt;/author&gt; &lt;price&gt;0.0&lt;/price&gt;&lt;/book&gt; 可以看出它和 html 长得很像，但是它一般没有属性和样式，仅仅是用有意义的标签来包裹数据，而 html 则需要那些东西让浏览器来渲染页面。上面的 XML 文件就存储了一本书的名称、作者和价格等信息。等我们需要这些数据的时候，用 js 来提取就行了。 PS: XML 和 html 一样，可以使用 标准DOM 来操作。 语法规则 所有元素标签由用户自己定义，元素本身没有实际意义。 html 中的标签都是规定的，自创的标签浏览器不会解析。 所有 XML 元素都必须有关闭标签。（声明没有关闭标签，这不是错误，声明不是 XML 文档本身的一部分） html中可以有单标签，比如: &lt;br&gt;、&lt;hr&gt;等 对大小写敏感。 标签 &lt;Letter&gt; 与标签 &lt;letter&gt; 是不同的。 XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。 一般情况下最外层的标签用 &lt;boot&gt; &lt;/boot&gt; 。这个是约定俗成的，你也可以用其他任何标签，不必纠结！！ 与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。 属性值必须用双引号包裹 &lt;note date=&quot;12/11/2007&quot;&gt; 在 XML 中，空格会被保留 html 中的连续空格在解析是会被合并为一个。 使用方法XML 的使用方法分为 IE中的XML（IE9-） 和 其他浏览器中的XML（支持DOM2、DOM3的浏览器，包括IE9+） DOM2中的XML主要有两个方法： DOMParser() 创建xmlDom对象然后使用 parseFromString() 方法来解析 xml 元素123var parser = DOMParser(); //创建xmlDom对象var xmlDom = parser.parseFromString('&lt;root&gt;&lt;/root&gt;','text/xml'); alert(xmlDom.docuemntElement.tagName); //root PS：DOMParser 只能解析格式良好的 XML，再发生错误时会从 parseFromString() 中返回一个 Document 对象，包含一个文档元素 &lt;parsererror&gt; ，内容为对解析错误的描述。所以在解析之后我们可以通过判断 &lt;parsererror&gt; 是否存在来判断是否解析错误！ XMLSerializer() 创建 XML 实例然后使用 serializeToString() 方法将DOM文档序列化为XML123var serializer = new XMLSerializer();var xml = serialize.serializeToString(xmlDom);alert(xml); IE中的XMLIE浏览器是最早支持 XML 的，早期 IE 中的 XML 是通过 ActiveX 对象实现的，直到现在这个对象也只有IE有，但只在 IE9 及之前的版本中使用。微软当年为了开发人员方便的处理 XML，创建了 MSXML 库，但却没有染 Web 开发人员通过浏览器访问相同的对象。（也就是说，这个MSXML库是存在你的 window 系统当中的，而不是浏览器自带的，能不能使用还和你的系统有关） 创建xmlDom对象要解析XML字符串，必须先创建一个xmlDom对象。1var xmlDom = new ActiveXObject('MSXML2.DOMDocument'); 说明： MSXML库有6个版本，不过只需要了解以下三种就可以了。（微软自己说的，不推荐使用另外那三种） MSXML2.DOMDocument.6.0 最可靠最新版本 MSXML2.DOMDocument.3.0 兼容性较好的版本 MSXML2.DOMDocument 针对IE5.5之前的版本使用 因为不同版本的MSXML库对不同浏览器的支持不相同，所以我们应该用兼容的方式来创建xmlDom对象：123456789101112131415161718function createXMLDOM()&#123; var version = [ 'MSXML2.DOMDocument.6.0', 'MSXML2.DOMDocument.3.0', 'MSXML.2.DOMDocument' ]; for(var i = 0;i &lt; version.length;i++)&#123; try&#123; var xmlDom = new ActiveObject(version[i]); return xmlDom; &#125; catch(ex)&#123; //这里跳过 如果这里写代码的话，当不支持6.0的话就会报错而不往下循环for语句 &#125; &#125; throw new Error('您的浏览器或浏览器不支持MSXML库！'); //三个版本都不支持是才抛出错误&#125; 加载XML加载XML分为两种：加载xml字符串、加载xml外部文件 加载xml字符串 使用 loadXML() 方法123var xmlDom = createXMLDOM();xmlDom.loadXML('&lt;boot&gt;&lt;name&gt;cwyaml&lt;/name&gt;&lt;/boot&gt;'); //直接把xml字符串写在里面就可以了 加载xml外部文件 使用 load() 方法123var xmlDom = createXMLDOM();xmlDom.load('demo.xml');//假如有一个 demo.xml 外部文件 错误处理如果解析过程出错，可以在parseError属性中找到错误信息。这个属性本身包含一个包含多个属性的对象，每个对象都保存着有关解析错误的某一方面信息。取得有关错误信息很简单：1234567if(xmlDom.parseError != 0)&#123; alert('一个错误：\n Error Code:' + xmlDom.parseError.errorCode + '\n' + 'line:' + xmlDom.parseError.line + '\n' + 'line Pos:' + xmlDom.parseError.linepos + '\n' + 'Reason:' + xmlDom.parseError.reason);&#125; 在载入XML文档之后，操作之前检查是否发生错误！！ 同步和异步load()方法用于服务器端载入XML时，存在两种加载方式：同步和异步。所谓同步：就是在加载XML完成之前，代码不会继续执行，完全加载后再返回。简单方便，但容易造成浏览器假死。所谓异步：加载XML时是浏览器后台处理，不会影响其他代码的执行。默认使用异步，也推荐使用异步加载。1xmlDom.async = fasle; //设置同步，不设置就是异步 在异步加载 XML 文件的情况下，需要为 XMLDOM 文档的 onreadystatechange 事件指定处理程序。通过 readyState 属性可以获得就绪状态，一共有四种，只需关注就绪状态：4。123456789101112var xmlDom = createDocument();xmlDom.async = true; //不设置也可以xmlDom.onreadystatechange = function()&#123; if(xmlDom.readyState == 4)&#123; //判断是否就绪 if(xmlDom.parsererror != 0)&#123; //错误处理！ &#125;else&#123; //执行DOM操作 &#125; &#125;&#125; PS：为 onreadystatechange 事件指定处理程序语句必须放在调用 load() 方法之前，这样才能确保就绪状态变化时调用这段事件处理程序 跨浏览器处理XML跨浏览器创建 xmlDom 对象首相声明 IE 中的 load() 方法在 DOM2 中没有与之对应的功能，所以不能做兼容12345678910111213141516171819202122//跨浏览器创建xmlDom对象function parseXML(xml)&#123; var xmlDom = null; if(typeof DOMParser != 'undefined')&#123; xmlDom = (new DOMParser()).parseFromString(xml,'text/xml'); var errors = xmlDom.getElementsByTagName('parsererror'); if(errors.length)&#123; throw new Error('XML parsing error:' + errors[0].textContent); &#125; &#125;else if(typeof ActiveXObject != 'undefined')&#123; xmlDom = createXMLDOM(); xmlDom.loadXML(xml); if(xmlDom.parsererror != 0)&#123; throw new Error('XML parsing error:' + xmlDom.parseError.reason); &#125; &#125;else &#123; throw new Error('No XML parser available.'); &#125; return xmlDom;&#125; 跨浏览器序列化 XMLDom12345678910//跨浏览器序列化xmlDOMfunction serializeXML(xmlDom)&#123; if(typeof XMLSerializer != 'undefined')&#123; return (new XMLSerializer()).serializeToString(xmlDom); &#125;else if(typeof xmlDom.xml != 'undefined')&#123; return xmlDom.xml; &#125;else &#123; throw new Error('不支持序列化xmlDom对象！'); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HEXO 博客同时部署到 GitHub & Coding]]></title>
      <url>%2F2017%2F03%2F08%2Fgithub%26coding%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人都把 hexo 托管到 Github 上，因为 Github 大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问 coding 比 github 是要快不少的。还可以利用域名解析实现国内的走 coding，海外的走github，分流网站的访问。 注册GitHub和Codinggithub官网 &nbsp;&nbsp;||&nbsp;&nbsp; Coding官网 &nbsp;&nbsp;注册就不必多说，不会的可自行百度。需要注意的是：最好使用同一个 用户名 和 邮箱 ，以免引起不必要的麻烦。 创建项目在GitHub上创建项目，名称为：yourname.github.io在Coding上创建项目，名称为：yourname 配置SSH配置 shh key 是让本地 git 项目与远程的 github 建立联系 获取ssh 检查是否已经有SSH Key，打开 Git Bash，输入 1cd ~/.ssh 如果没有 .ssh 这个目录，则生成一个新的 SSH，输入 1ssh-keygen -t rsa -C &quot;your e-mail&quot; 注意: 此处的邮箱地址，是你注册 GitHub 和 coding 时的邮箱地址; 此处的「-C」的是大写的「C」 。 接下来几步都直接按回车键,然后系统会要你输入密码 (防止别人往你的项目里提交内容) 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 成功后，我们打开 C:\Users\cwyaml.ssh 打开 id_rsa.pub 文件。里面的代码就是 ssh key。 添加 SSH Key 到 GitHub 和 CodingGitHub添加方法： 进入Github官网，点击头像，再按 settings 进入设置。 点击 New SSH key 创建 title输入邮箱，key里面粘贴刚才右击复制的内容,再点 Add SSH key 即可。（会让你输入密码） Coding添加方法： 登录账号后点击 左侧账户 在点 SSH公钥 设置即可 。（同样要输入密码） 测试SSH是否配置成功打开 Git Bash，首先测试 GitHub 是否成功？输入:1ssh -T git@github.com (如配置了密码则要输入密码,输完按回车。)如果显示以下内容，则说明 Github 中的 ssh 配置成功。12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 然后测试 Coding 是否成功？1ssh -T git@git.coding.net 如果显示以下则说明配置成功：1Hello username You&apos;ve connected to Coding.net by SSH successfully! 上传博客文件修改站点配置文件：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:cwyaml/cwyaml.github.io.git,master coding: git@git.coding.net:cwyaml/cwyaml.git,master 然后你就可以 hexo c、hexo g、hexo d 了。 开启pages服务GitHub 已经默认开启，就不必多说了。Coding 进入对应项目，点击 代码&gt;pages服务 ，把部署来源改为 master 即可。 访问博客这样我们整个部署过程就完成了。有两个地址可以访问我们的博客：GitHub pages：https://cwyaml.github.ioCoding pages：https://cwyaml.coding.me]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HEXO+GitHub,搭建博客 - 备份]]></title>
      <url>%2F2017%2F03%2F07%2Fbackup%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用Hexo写博客是一件比较享受的事情，无奈如果换电脑或者系统崩了的话，你就会一脸懵B了，备份博客就显得尤为重要。先说说我的感受，博客刚搭建好的时候就想过这个问题，那时候对 git 似懂非懂吧。在网上找了很多教程方法，大概就是说要创建一个分支来存放 blog 文件，但是翻腾来翻腾去还是没有搞定。 最后索性简单粗暴点，在 GitHub 上创建一个仓库，把 blog 文件整个打包上传。使用过程中发现这个方法还不错，至少对于小白来说很容易理解，也很难出错，就一直沿用到现在。 这种方式虽然能够备份 Hexo 博客的源文件，但是对于博主这种懒人，每次更新博文都需要输入两三行重复的Git命令真是一件麻烦的事情。 自动备份准备本方法需要提前将 Hexo 加入 Git仓库 并与 Github 远程仓库绑定之后，才能正常工作。具体做法可以参考：上传本地项目到GitHub 安装 shelljs 模块要实现这个自动备份功能，需要依赖 NodeJs 的一个 shelljs 模块,该模块重新包装了 child_process,调用系统命令更加的方便。使用以下命令，完成 shelljs 模块的安装：1npm install --save shelljs 编写自动备份脚本待到模块安装完成，在Hexo根目录 的 scripts文件夹下新建一个js文件，文件名随意取。如果没有scripts目录，请新建一个。123456789101112131415161718192021222324252627282930require(&apos;shelljs/global&apos;);try &#123; hexo.on(&apos;deployAfter&apos;, function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(&quot;产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：&quot; + e.toString());&#125;function run() &#123; if (!which(&apos;git&apos;)) &#123; echo(&apos;Sorry, this script requires git&apos;); exit(1); &#125; else &#123; echo(&quot;======================Auto Backup Begin===========================&quot;); cd(&apos;C:/Blog&apos;); //此处修改为Hexo根目录路径 if (exec(&apos;git add .&apos;).code !== 0) &#123; echo(&apos;Error: Git add failed&apos;); exit(1); &#125; if (exec(&apos;git commit -m &quot;Form auto backup script\&apos;s commit&quot;&apos;).code !== 0) &#123; echo(&apos;Error: Git commit failed&apos;); exit(1); &#125; if (exec(&apos;git push origin master&apos;).code !== 0) &#123; echo(&apos;Error: Git push failed&apos;); exit(1); &#125; echo(&quot;==================Auto Backup Complete============================&quot;) &#125;&#125; 注意： 其中，需要修改第17行的 D:/hexo 路径为 Hexo的根目录 路径。（脚本中的路径为博主的Hexo路径） 如果你的Git远程仓库名称不为 origin 的话，还需要修改第28行执行的push命令，修改成自己的远程仓库名和相应的分支名。 测试保存脚本并退出，然后执行 hexo d 命令，将会得到类似以下结果:12345678910111213141516171819202122232425262728293031323334353637383940INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder.........======================Auto Backup Begin===========================warning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/hexo1.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/update to github.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/wangyimusic.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in themes/next-5.0.1/layout/_partials/head.swig.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/backup.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/encrypt.md.The file will have its original line endings in your working directory.[master 1bb6cc5] Form auto backup script&apos;s commit Committer: unknown Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly. Run thefollowing command and follow the instructions in your editor to edityour configuration file: git config --global --editAfter doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 6 files changed, 177 insertions(+), 2 deletions(-) create mode 100644 scripts/autobackup.js create mode 100644 source/_posts/backup.md create mode 100644 source/_posts/encrypt.mdTo https://github.com/cwyaml/blog-backup.git d7bc718..1bb6cc5 master -&gt; master==================Auto Backup Complete============================ 这样子，每次更新博文并 deploy 到服务器上之后，备份就自动启动并完成备份啦~是不是很方便呢？ Enjoy it！ 参考：wanghao大神 自动备份Hexo博客源文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[教你制作音乐外链]]></title>
      <url>%2F2017%2F03%2F02%2Fwangyimusic%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章讲怎样制作音乐外链，我主要用来为自己的博客添加背景音乐。（其实主要用来装X） 通用方法首先你需要下载想要的歌曲：QQ音乐、网易云音乐需要安装客户端才能下载。虾米音乐可以在网页直接下载。总之把需要的歌曲下载下来就可以了！！ 我们利用 七牛云存储 来自动生成歌曲外链。第一步：注册、登录第二步：在对象存储中新建一个仓库，命名为 music 。第三步：在内容管理中上传歌曲文件 用这种方法所有歌曲（只要能下载）都能获得，并且永久有效 网易云音乐获取方法第一步： 先获取歌曲id，直接打开网易云音乐网页版: http://music.163.com搜索自己喜欢的音乐，并获取歌曲的 ID 。举个例子：（id很明显吧） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://music.163.com/#/song?id=443205403 第二步： 将下面网址中的两处id替换成的歌曲idhttp://music.163.com/api/song/detail/?id=425137664&amp;ids=[425137664]&amp;csrf_token=你将会获得一大串代码：外链就隐藏其中。。找不到的话就把这段代码复制到编辑器里，ctrl+F 查找 .mp31234567891011121314&#123;&quot;songs&quot;:[&#123;&quot;name&quot;:&quot;原来都是梦 &quot;,&quot;id&quot;:425137664,&quot;position&quot;:1,&quot;alias&quot;:[],&quot;status&quot;:0,&quot;fee&quot;:0,&quot;copyrightId&quot;:0,&quot;disc&quot;:&quot;&quot;,&quot;no&quot;:1,&quot;artists&quot;:[&#123;&quot;name&quot;:&quot;李行亮&quot;,&quot;id&quot;:4093,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p4.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;],&quot;album&quot;:&#123;&quot;name&quot;:&quot;原来都是梦&quot;,&quot;id&quot;:34816208,&quot;type&quot;:&quot;EP/Single&quot;,&quot;size&quot;:2,&quot;picId&quot;:3432675310535810,&quot;blurPicUrl&quot;:&quot;http://p3.music.126.net/LNL0l5xhstsgIILEaVkprg==/3432675310535810.jpg&quot;,&quot;companyId&quot;:0,&quot;pic&quot;:3432675310535810,&quot;picUrl&quot;:&quot;http://p3.music.126.net/LNL0l5xhstsgIILEaVkprg==/3432675310535810.jpg&quot;,&quot;publishTime&quot;:1470844800007,&quot;description&quot;:&quot;&quot;,&quot;tags&quot;:&quot;&quot;,&quot;company&quot;:&quot;百纳娱乐&quot;,&quot;briefDesc&quot;:&quot;&quot;,&quot;artist&quot;:&#123;&quot;name&quot;:&quot;&quot;,&quot;id&quot;:0,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;,&quot;songs&quot;:[],&quot;alias&quot;:[],&quot;status&quot;:0,&quot;copyrightId&quot;:0,&quot;commentThreadId&quot;:&quot;R_AL_3_34816208&quot;,&quot;artists&quot;:[&#123;&quot;name&quot;:&quot;李行亮&quot;,&quot;id&quot;:4093,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;],&quot;subType&quot;:&quot;录音室版&quot;&#125;,&quot;starred&quot;:false,&quot;popularity&quot;:100.0,&quot;score&quot;:100,&quot;starredNum&quot;:0,&quot;duration&quot;:262500,&quot;playedNum&quot;:0,&quot;dayPlays&quot;:0,&quot;hearTime&quot;:0,&quot;ringtone&quot;:null,&quot;crbt&quot;:null,&quot;audition&quot;:null,&quot;copyFrom&quot;:&quot;&quot;,&quot;commentThreadId&quot;:&quot;R_SO_4_425137664&quot;,&quot;rtUrl&quot;:null,&quot;ftype&quot;:0,&quot;rtUrls&quot;:[],&quot;copyright&quot;:0,&quot;rurl&quot;:null,&quot;mvid&quot;:0,&quot;rtype&quot;:0,&quot;bMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538623,&quot;size&quot;:3150725,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605233,&quot;bitrate&quot;:96000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.21&#125;,&quot;mp3Url&quot;:&quot;http://m2.music.126.net/eU871p87-mpm5JcrqnsP2w==/1413971967605233.mp3&quot;,&quot;hMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538621,&quot;size&quot;:10502313,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605231,&quot;bitrate&quot;:320000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.63&#125;,&quot;mMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538622,&quot;size&quot;:5251179,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605232,&quot;bitrate&quot;:160000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.19&#125;,&quot;lMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538623,&quot;size&quot;:3150725,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605233,&quot;bitrate&quot;:96000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.21&#125;&#125;],&quot;equalizers&quot;:&#123;&#125;,&quot;code&quot;:200&#125; 第三步： 将上一步中获取到的网址放到地址栏中，若能正常播放音乐说明获取到的网址是正确的。然后你就可以把这些歌曲添加到自己的网页中了！！ 用这种方法有些歌曲并不能获得，不过时效很长（只要网易云能听）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最简单的翻墙方法]]></title>
      <url>%2F2017%2F03%2F01%2Fhost%2F</url>
      <content type="text"><![CDATA[分享一个可用的翻墙方法，解决 Google、Facebook、及 Twitter 等被墙问题。 ※※※ 本页面长期更新可用 hosts 文件。 ※※※ 废话不多说,直接讲方法只需要替换系统的 hosts 文件，就可以使用google、facebook… hosts 所在文件夹： Windows 系统hosts位于 C:\Windows\System32\drivers\etc\hosts Android（安卓）系统hosts位于 /etc/hosts Mac（苹果电脑）系统hosts位于 /etc/hosts iPhone（iOS）系统hosts位于 /etc/hosts Linux 系统hosts位于 /etc/hosts 绝大多数Unix系统都是在 /etc/hosts 可用hosts文件 提取码：b69i 解压密码：laod 注意Google、Gmail、维基百科、Twitter、Facebook等必须请用https加密方式打开。一般这些网站都是SSL加密链接，如：谷歌学术：https://scholar.google.com/谷歌：https://www.google.com/ncr谷歌香港：https://www.google.com.hk/ncrTwitter：https://twitter.com/?lang=zh-cn]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Naruto-Pictures]]></title>
      <url>%2F2017%2F02%2F28%2Ftop-pitcure%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 使用中常见的问题及解决方法]]></title>
      <url>%2F2017%2F02%2F14%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像 Markdown 官方文档里描述的一样：可读性，无论如何，都是最重要的。Markdown 的目标是实现 &nbsp; 『易读易写』 。&nbsp;Markdown 从发布到现在备受好评，经过这一段的使用，整体感觉挺顺手，不过还是存在很多问题，所以总结一下喽。。 编辑器其实自己喜欢的才是最好的。(像 vim 、emacs什么的不推荐，因为我也不会用) MAC平台自己没用过，不做推荐。你可以看看这个帖子：Mac 上适合码农用的 Markdown 编辑器是什么？ Windows平台印象笔记马克飞象传送门，界面不是很好看，书写的时候感觉很别扭 有道云笔记有道传送门，同样很丑，强迫症受不了 Sublime Text强大的 Sublime Text 总是能给我们很多惊喜，经过各种对比，sublime 满足了我对审美的要求。首先我们需要安装两个插件：（至于怎么安装就不说了） markdownEditing 用来书写 markdownPreview 用来预览 AtomGitHub 推出的编辑器，界面很好（就是启动有点慢），必须支持一下。同样安装插件： markdown-preview 这一个就可以了 使用方法Markdown官方文档 常见问题汇总html标签显示比如说我要写一篇博客，标题为“html中 &lt;canvas&gt; 的使用”1## html中 &lt;canvas&gt; 的使用 如果这样写就会出现排版上的问题（不信你试一下），那么怎么解决呢？其实认真想一下就能明白，Markdown 的语法是基于 html 的，我们直接写 &lt;canvas&gt;，自然会被理解为一个标签，而不是要显示的文本。。所以，问题回归到 html 上。在网页中，我们要显示 &lt;canvas&gt; 时要用到 转义字符, 所以 Markdown 中也一样，我们应该这样写：1## html中 &amp;lt;canvas&amp;gt; 的使用 代码语法高亮这个问题困扰了我好久，官方文档里竟然没有说明！只好自己去查找方法。Markdown 中显示代码块是这样的格式：显示为：1&lt;p&gt;这是一个p标签&lt;/p&gt; 而我们这样写：就可以实现代码高亮了1&lt;p&gt;这是一个p标签&lt;/p&gt; 据说这种方式一共支持四十多种语言，有兴趣的话你可以研究一下。 图片Markdown 中嵌入图片，如果使用本地图片就要用到 html 标签来引用，这种方法很稳定，但是使文档变得很大（一张图片最少几百k吧）。所以我们要用到 图床 。 贴图库推荐使用 &nbsp; 贴图库 &nbsp;快速，免费（我使用过程中没掉过链子） 注册登录，就可以上传图片，每张图片自动生成 原图、展示图和 缩略图的图片外链、html代码、Markdown外链等。只要把对应的代码粘贴到你的文档中就可以了。。 七牛云存储这个最近很火，可靠、可扩展、低成本等等有很多优点。你可以试一下。我们主要用到他的 对象存储 服务，创建一个公开仓库，把图片上传就可以生成外链了。 gifGithub 上的开源项目，ReadMe.md 是也支持 Markdown 语法的，通常会看到很多开源项目的 ReadMe 中有 动态演示效果，看到这个项目的人一目了然，非常方便，gif本身也是一种图片格式，在 Markdown 中 引用时和正常图片的引用一样，但需要专门的工具生成 gif 格式的图片才行，在这里强烈推荐 LICEcap，它是一款 windows 上的录屏软件，录制后保存的格式为 gif，体积小并且同样也可以在图床上生成链接。 插入音乐你可以把音乐文件下载到本地，然后简单粗暴的使用 html 中的 &lt;video&gt; 标签。当然，如果这样就不必写下去了，告诉你简单的方法：网易云音乐 打开网易云音乐网页版，搜索自己喜欢的音乐，比如我找到 告白气球 我们可以看到在图片的下边有一个 生成外链播放器 , 点击会出现 选择 合适的尺寸 和 播放模式 之后。把下边的代码复制到你的 Markdown 文档中就可以了。试着听一下吧！！(我选择了最小尺寸) 试着去把一个 歌单生成外链播放器 插入到你的 Markdown 中，这样你跟新歌单你的博文也会跟着变化，而不必在想跟换歌曲时头疼]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 之 canvas的使用]]></title>
      <url>%2F2017%2F02%2F13%2Fhtml5-canvas%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canvas是 html5 出现的新标签，用来替代Flash。像所有的 DOM 一样它具有自己本身的属性、方法和事件。他拥有强大的绘图功能。。下面是我在学习时做的一些总结。 开始使用canvas元素创建一个画布canvas元素里的内容会在浏览器不支持该元素时显示。123&lt;canvas id="myCanvas"&gt; your browser doesn't support the &lt;code&gt;canvas&lt;/code&gt; element.&lt;/canvas&gt; 使用js来绘制图像canvas本身并咩有绘图能力，所有的绘制工作必须在js内部完成。以绘制矩形为例。。 首先找到 canvas 元素： 1var c = document.getElementById("myCanvas"); 然后创建 context 对象： 1var ctx = c.getContext("2d"); 绘制一个矩形： 1ctx.fillRect(0,0,150,75); 就是这么简单！！ 设置画布绘制状态绘图操作由 绘制状态 加以配置。后者是一组属性，指定了从线条宽度到填充色的所有参数。所以当我们绘制一个图形时，会用到当前绘制状态的设置。主要有这几种： fillStyle 用于设置填充颜色，默认为 #000； lineWidth 用于设置线条的宽度，默认 1.0； strokeStyle 用于设置线条的颜色，默认 #000； lineJoin 用于设置线条与图形连接时的样式，有三个参数 round、bevel和miter，默认 miter. 前面3个很好理解，我们介绍一下 lineJoin ，直接上代码：123456789101112131415&lt;canvas id="myCanvas" width="450px" height="300px"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; var c = document.getElementById("myCanvas"); var ctx = c.getContext('2d'); ctx.lineWidth = 20; ctx.lineJoin = "round"; ctx.strokeRect(20,20,100,100); ctx.lineJoin = "bevel"; ctx.strokeRect(160,20,100,100); ctx.lineJoin = "miter"; ctx.strokeRect(300,20,100,100);&lt;/script&gt; 效果：（差别很明显） 使用渐变除了纯色，我们还可以把填充和笔触样式设置成渐变色。canvas元素支持两类渐变：线性和径向。 createLinearGradient(x,y,x1,y1) 创建一个线性方向和大小 createRadialGradient(x,y,r,x1,y1,r1) 创建一个径向范围 以上两个方法都返回一个 CanvasGradient 对象，我们对这个对象使用 addColorStop(position,color) 方法来实现渐变。(position的值为 0-1) 。 实现一个线性渐变 适当的调整 梯度线 和 绘制大小 的关系，可以实现不同的效果。。 直接上代码：12345678910111213&lt;canvas id="myCanvas" width="450px" height="300px"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var c = document.getElementById("myCanvas"); var ctx = c.getContext('2d'); var grad = ctx.createLinearGradient(20,20,300,200); grad.addColorStop(0,"red"); grad.addColorStop(.3,"yellow"); grad.addColorStop(1,"black"); ctx.fillStyle = grad; ctx.fillRect(20,20,300,200);&lt;/script&gt; 实现一个径向渐变我们用两个圆来定义径向渐变。渐变的起点由第一个圆定义，终点由第二个圆定义，在两者之间添加颜色。就像这样：（我们试着画一个太阳的样子）12345678910111213&lt;canvas id="myCanvas" width="450px" height="300px"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; var c = document.getElementById("myCanvas"); var ctx = c.getContext('2d'); var grad = ctx.createRadialGradient(225,150,20,225,150,300); grad.addColorStop(0,"red"); grad.addColorStop(.2,"yellow"); grad.addColorStop(1,"black"); ctx.fillStyle = grad; ctx.fillRect(20,20,450,300);&lt;/script&gt; 保存和恢复绘制状态]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单博文加密]]></title>
      <url>%2F2017%2F02%2F07%2Fencrypt%2F</url>
      <content type="text"><![CDATA[即使是最简单的加密方式也足以阻止90%的访问者 原理由于 Hexo 最终编译出来的是静态文件，也就意味着文章的所有信息会原封不动展示在页面中，当你输入一篇文章的地址，所有的内容就已经跟随网络传输过来了。那么博客使用加密是怎么实现的呢？ 这就要讲到 js 的阻塞机制了，当调用 alert(); 函数的时候，整个页面会停止运行，直到你点击确定之后，才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是 alert(); 只有提醒的功能，没有输入的功能，所以，这里要用到的是 promt() 方法。 promt()方法介绍这个 promt() 方法有什么作用呢？查看js文档可以知道： prompt()方法 : 用于显示可提示用户进行输入的对话框。如果用户单击提示框的 取消 按钮，则返回 null。如果用户单击 确认按钮，则返回 输入字段当前显示的文本（用户输入的文本）。 我们就是利用 promt() 方法可以返回用户输入的文本这个特性，获取到返回数据，与我们设置的密码进行验证，从而实现文档加密的。。 实践找到 themes\next\layout\_partials\head.swig 文件。在 &lt;meta&gt; 标签之后添加以下代码：12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;,&apos;&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 这里有必要解释一下 page.password 是什么东西。以下我给出这篇文章的头部参考：首先 page 是一个变量，你可以理解为这篇文章。以下面的代码为参考，那么 page.title = 最简单的翻墙方法; page.comments = fasle;（很好理解吧）123456title: 最简单的翻墙方法date: 2017-03-01 12:01:05tags: [翻墙,hosts]categories: [外面的世界]keywords: 翻墙,hostscomments: false 所以，要想加密博文，我们要为文章加上 password 属性。description 属性用于对文章进行描述。（加密下显示内容）12description: 文章访问密码：passwordpassword: password 总结这种方式只能说是一点小技巧的应用吧，在大神面前可能不管用，但足以阻挡大多数用户。更完美的博文加密方式请参考：加密博客内容，使用密码访问]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HEXO+GitHub搭建博客 - 优化]]></title>
      <url>%2F2017%2F01%2F25%2Fhexo2%2F</url>
      <content type="text"><![CDATA[本篇文章主要介绍基于NexT主题的一些第三方功能的实现。基本功能的设置可以参考Next官网文档 首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。我们约定，将前者称为 站点配置文件 ，后者称为 主题配置文件。 背景动态背景修改 _layout.swig 模板模板位置：themes\next\layout\_layout.swig在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）12345&lt;!-- 动态背景 --&gt;#默认灰色线条&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt;#浅蓝色线条&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在 themes\source\js\src\ 下新建文件 particle.js 写上以下代码:1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 鼠标点击小红心在 \themes\next\source\js\src 文件目录下添加 love.js 文件。内容为：1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：12&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 头像圆形旋转修改文件 themes/next/source/css/_common/components/sidebar/sidebar-author.styl我的样式文件 文章结尾模板在 \themes\next\_macro 文件目录下添加 passage-end-tag.swig 文件，内容为：(当然你也可以修改为自己喜欢的样式)1234567891011121314&#123;% if theme.passage_end_tag.enabled %&#125;&lt;blockquote class="blockquote-center"&gt; &lt;p&gt;如果您觉得本博客还不错，欢迎继续关注本博客，欢迎多提宝贵意见，非常感谢！&lt;/p&gt;&lt;/blockquote&gt;&lt;span id="inline-green" style="border-radius:3px;"&gt;作者&lt;/span&gt;：&lt;a class="link-blue" href="https://github.com/cwyaml" target="_blank"&gt;cwyaml&lt;/a&gt;有问题请 &lt;a class="link-blue" href="https://cwyaml.github.io/about/"&gt;留言&lt;/a&gt; 或者私信我的 &lt;a class="link-blue" href="http://weibo.com/u/5742789641?refer_flag=1001030102_&amp;is_all=1" target="_blank"&gt;微博&lt;/a&gt;。&lt;div style="text-align:center; color:#ccc; font-size:14px; "&gt; ------本文结束 &amp;nbsp;&lt;i class="fa fa-paw"&gt;&lt;/i&gt;&amp;nbsp; 感谢阅读------&lt;/div&gt;&#123;% endif %&#125; 找到 \themes\next\_macro\post.swig 文件，使用查找功能找到 reward.swig，在这一个 &lt;div&gt; 的前面添加：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 文章底部标签云锚点在 themes\next\layout\_macro\post.swig 文件中找到以下代码：12345678910&lt;footer class="post-footer"&gt;&lt;!--这是文章底部标签云锚点，不喜欢就注释掉 &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;--&gt; 关于文章内文本样式Markdown 毕竟是为了方便写作，在样式上就过于单调。我们自己来给文章加一些样式。。 Next 作者提供了一个供用户自己定义样式的文件：\themes\next\source\css\_custom\custom.stl 自己按需要写在上述文件中写上自己的 class 类，然后在 Markdown 文档中使用。我的custom.styl 引用前端框架目前流行的前端框架，像 bootstrap、React、Angular 等，提供给我们很好的前端方案，我们可以把喜欢的引入到上面说的那个文件里，然后就可以使用了。 设置动态title 在 \themes\next\source\js\src 目录下新建 dytitle.js 。添加以下内容： 1234567891011121314151617&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/TEP.ico&quot;); document.title = &apos; 页面崩溃啦 ~ | cwyaml！&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/favicon.ico&quot;); document.title = &apos; 噫又好了~ &apos; + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); 更改 \themes\next\layout\_layout.swig 。在 &lt;/body&gt; 之前添加： 12&lt;!--崩溃欺骗--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/dytitle.js&quot;&gt;&lt;/script&gt; 首页动画在 主题配置文件 中，找到 Motion 字段。true 和 false 控制动画的开启与关闭。12# Motionuse_motion: true 内容宽度现在一般的笔记本都在15寸以上，博客页面两侧留白太多就显得没有必要，并且不美观，所以有必要调整一下宽度。（可以慢慢试着调整到最合适的状态） 找到 \themes\next\source\css\_common\components\post\post-expand.styl，找到： 123@media (max-width: 767px)改为：@media (max-width: 1060px) 找到：\themes\next\source\css\ _variables\base.styl ，找到： 123456789$main-desktop = 960px$main-desktop-large = 1200px$content-desktop = 700px改为：$main-desktop = 1060px$main-desktop-large = 1200px$content-desktop = 800px 找到 \themes\next\source\css\_schemes\Pisces\_layout.styl ，将第 4 行的 width 改为 1060px ，修改后如下： 1234.header &#123; position: relative; margin: 0 auto; width: 1060px; 统计功能文章阅读次数统计参考： LeanCloud 不蒜子统计站点访问 全局配置：编辑 主题配置文件 中的 busuanzi_count 的配置项，配置以下内容：当 enable: true 时，代表开启全局开关。若 site_uv、site_pv、page_pv 的值均为 false 时，不蒜子仅作记录而不会在页面上显示。 站点 UV/PV 配置：当 site_uv: true 时，代表在页面底部显示站点的 UV 值。当 site_pv: true 时，代表在页面底部显示站点的 PV 值site_uv_header(site_pv_header) 和 site_uv_footer(site_pv_footer) 为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为 [site_uv_header]UV值/PV值[site_uv_footer]。 1234567891011busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站总访问量 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: 您是第 site_pv_footer: 位小伙伴 单页面 PV 值设置： 1234# custom pv span for one page onlypage_pv: falsepage_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;page_pv_footer: 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址（放在博客根目录的source文件夹下即可） 即可开启该功能。123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /weixin.pngalipay: /zhifubao.png 设置RSS 需要安装 hexo-generator-feed 插件。 1$ npm install hexo-generator-feed --save 在 站点配置文件 中添加字段： 123456feed: type: atom path: atom.xml limit: 20 hub: content: 听音乐 下载js文件：high.swig。放在 \themes\next\layout\_macro 目录下。 在侧边栏引用该文件：修改 \themes\next\layout\_macro\sidebar.swig ，添加以下代码： 1&#123;% include &apos;high.swig&apos; %&#125; 样式修改：使 听音乐 和 RSS 并排展示，修改 \themes\next\source\css\_schemes\Pisces\_sidebar.styl 1display: inline-block; 添加自己喜欢的音乐：修改其中的歌曲链接即可（获取歌曲外链教程） 123456var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; 首页听音乐摇晃：需要加载css样式。在 themes\next\layout\_layout.swig 文件的 body标签结束前 添加以下代码： 12&lt;!-- 听音乐摇晃 --&gt;&lt;link href="http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css" rel="stylesheet" type="text/css"&gt; 注意： 有时候使用 Firefox 、Chrome时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 \themes\next\source\css\_custom\custom.stl 文件即可解决。 添加 Forkme on GitHub 丝带首先进入 GitHub Ribbons 选择自己喜欢的丝带样式。找到 \themes\next\layout\_layout.swig 文件，在 &lt;header&gt; 标签前面添加：（记得把链接修改成自己的GitHub主页）1&lt;a href="https://github.com/you"&gt;&lt;img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"&gt;&lt;/a&gt; 给 Blog 添加 LICENSE修改 主题配置文件 （使用查找功能）12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: Local Search 安装 hexo-generator-searchdb 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件 ，添加以下字段： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件 ，启用本地搜索 123# Local searchlocal_search: enable: true 多说多说评论使用多说前需要先在 多说 创建一个站点。具体步骤如下： 登录后在首页选择“我要安装”。 创建站点，填写站点相关信息。多说域名 这一栏填写的就是你的 duoshuo_shortname, 创建站点完成后在 站点配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值即可。 多说评论框自定义 : 我的样式代码 多说分享在 主题配置文件 中设置：12# Shareduoshuo_share: true 禁用鼠标经过时分享更多功能（有bug）:找到 \themes\next\layout\_partials\share\duoshuo_share.swig 文件，替换内容为：123456789101112131415161718&lt;div class="ds-share flat" data-thread-key="&#123;&#123; page.path &#125;&#125;" data-title="&#123;&#123; page.title &#125;&#125;" data-content="" data-url="&#123;&#123; page.permalink &#125;&#125;"&gt; &lt;div class="ds-share-inline"&gt; &lt;ul class="ds-share-icons-16"&gt; &lt;li&gt;&lt;span class="ds-more"&gt;分享到：&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-weibo" href="javascript:void(0);" data-service="weibo"&gt;微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qzone" href="javascript:void(0);" data-service="qzone"&gt;QQ空间&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qqt" href="javascript:void(0);" data-service="qqt"&gt;腾讯微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-wechat" href="javascript:void(0);" data-service="wechat"&gt;微信&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-facebook" href="javascript:void(0);" data-service="facebook"&gt;Facebook&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-google" href="javascript:void(0);" data-service="google"&gt;Google&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="ds-share-icons-more"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp插件。hexo-all-minifier 虽然使用比较简单，而且也可以压缩图片，但是对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用 gulp 压缩手段。 hexo-all-minifier 使用方法安装 hexo-all-minifier，在站点的根目录下执行以下命令：1$ npm install hexo-all-minifier --save hexo g 编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 hexo-all-minifier glup 使用方法hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;amp;&amp;amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 博文置顶 修改 hexo-generator-index 插件。替换文件：node_modules/hexo-generator-index/lib/generator.js 为：generator.js 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：1234567---title: cwyaml 图集categories: [图片]tags: [picture]date: 2015-04-02 14:36:04top: 10--- 博文部署 message在 \node_modules\hexo-deployer-git\lib\deployer.js 文件末尾找到这一句：（记得个性一点）1Lucky Boy: &#123;&#123; now(\&apos;YYYY-MM-DD HH:mm:ss\&apos;) &#125;&#125;. 图片模式 新建博文，设置 type: &quot;picture&quot;，使用 {\% gp x-x \%} ... {\% endgp \%} 标签引用要展示的图片地址，如下所示：(其中的 x-x 为图片展示效果，可以自己尝试一下) 123456789101112131415---title: Naruto-Picturescategories: [图片]tags: [picture]date: 2014-06-02 10:36:02type: "picture"comments: false---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你还不知道 gtihub 吗？]]></title>
      <url>%2F2017%2F01%2F08%2Fupdate%20to%20github%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GitHub的本意是旨在成为一种开放的软件协作平台，但它目前已成为一个巨大的综合性的平台，其作用远远超过单纯地开源代码。它已经被新一代的人们授权进行协作、创造和生产。GitHub不仅仅是一个工具：我们正在见证一个新文化的诞生。 将本地项目上传到 GitHub 有很多种方法，综合来看使用 git 命令行的方法最简单方便，所以这里只介绍这方法。。 建立git仓库cd到你的本地项目根目录下，执行git命令：1git init 将项目的所有文件添加到仓库中1git add . 如果只想添加某个特定的文件，只需要把 . 换成特定的文件名即可 将add的文件commit到仓库1git commit -m &quot;注释语句&quot; 到GitHub上创建自己的Repository,创建页面如下图所示： 仓库创建完成后，我们要拿到仓库的https地址，红框里的： 重点！！将本地的仓库关联到GitHub1git remote add origin https://github.com/...... 后面的是你上一步获取到的仓库url 上传GitHub之前，需要先pull一下1git pull origin master 最后一步，上传本地项目到GitHub远程仓库1git push -u origin master 执行完成后，如果没有异常，等待一会就可以了，中间可能会让你输入username和password，你只要输入自己的GitHub账号和密码就好了。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HEXO+GitHub,搭建博客 - 配置]]></title>
      <url>%2F2016%2F12%2F24%2Fhexo1%2F</url>
      <content type="text"><![CDATA[本篇文章主要介绍怎样利用 Hexo + Next 在 GitHub 上搭建个人博客。 简介&nbsp;&nbsp;Hexo 是一个快速、简洁且高效的静态站点生成框架，基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 &nbsp; 精于心，简于形 &nbsp; 的风格，一直被广大用户所喜爱。 准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，跳过这一步。如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Now windows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。（执行完以后，我们同样可以执行命令 hexo -v 查看是否安装成功就安装成功了。）1$ npm install -g hexo-cli Hexo安装完成后，我们需要为我们的blog项目创建一个指定文件夹（例如我在 D 盘根目录下创建了一个文件夹 blog 。D:\blog ），在该文件夹中执行以下命令， Hexo 将会在指定文件夹中新建所需要的文件。12$ hexo init$ npm install 等待安装，安装完成后，指定文件夹 的目录如下：1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 继续执行命令12$ hexo g //编译$ hexo s --debug //开启本地服务 这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 到目前为止我们的本地博客已经部署完成。下面我们换上Next主题。 使用Next主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 启用 NexT 主题打开 站点配置文件 (Hexo文件夹下的_config.yml文件)，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们依次执行以下命令验证主题是否正确启用。 123$ hexo clean$ hexo g$ hexo s 我们在浏览器中访问 http://localhost:4000/ ，你将看到： 总结本地调试三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带debug的运行，如果出现错误，可以在命令行中看到错误提示信息。]]></content>
    </entry>

    
  
  
</search>
